<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - My Study Guide</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #fafafa;
            --surface: #ffffff;
            --text: #1a1a1a;
            --text-light: #666666;
            --border: #e0e0e0;
            --accent: #ff8c42;
            --accent-light: #ffa366;
            --success: #10b981;
            --danger: #ef4444;
            --bg-hover: #f5f5f5;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 24px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
        }

        .back-link {
            color: var(--text);
            text-decoration: none;
            font-size: 0.875rem;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 16px;
            transition: opacity 0.2s;
        }

        .back-link:hover {
            opacity: 0.7;
        }

        .user-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
        }

        .user-name {
            color: var(--text);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .auth-status {
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.02em;
        }

        .auth-status.local {
            color: #f59e0b;
        }

        .auth-status.authenticated {
            color: var(--success);
        }

        .auth-status.required {
            color: var(--danger);
        }

        .logout-link {
            color: var(--text-light);
            text-decoration: none;
            font-size: 0.875rem;
            transition: color 0.2s;
        }

        .logout-link:hover {
            color: var(--text);
        }

        h1 {
            font-size: 2rem;
            font-weight: 600;
            margin: 0;
            color: var(--text);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-light);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--bg-hover);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.8125rem;
        }

        .card {
            background: var(--surface);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--border);
        }

        .category-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text);
        }

        .subcategory-section {
            margin-top: 20px;
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .subcategory-content.hidden {
            display: none !important;
        }

        .hidden {
            display: none !important;
        }

        .subcategory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .toggle-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            color: var(--text-light);
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
            line-height: 1;
        }

        .toggle-btn:hover {
            background: var(--bg-hover);
            color: var(--text);
        }

        .subcategory-content {
            margin-top: 12px;
        }

        .subcategory-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
        }

        .topics-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .topic-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 8px;
            background: var(--bg);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .topic-item:hover {
            background: var(--bg-hover);
        }

        .topic-name {
            flex: 1;
            font-size: 0.9375rem;
            min-width: 300px;
        }

        .topic-actions {
            display: flex;
            gap: 8px;
        }

        .input-group {
            margin-bottom: 16px;
        }

        .input-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text);
        }

        .input-group input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.9375rem;
            font-family: inherit;
            background: var(--surface);
            color: var(--text);
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .add-category-form, .add-topic-form {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid var(--border);
        }

        .form-row {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .form-row .input-group {
            flex: 1;
            margin-bottom: 0;
        }

        .message {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 0.875rem;
        }

        .message-success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .message-error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--text-light);
            text-decoration: none;
            font-size: 0.875rem;
            margin-bottom: 24px;
        }

        .back-link:hover {
            color: var(--text);
        }

        @media (max-width: 768px) {
            .container {
                padding: 24px 16px;
            }

            .category-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }

            .form-row {
                flex-direction: column;
            }

            .topic-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .topic-actions {
                width: 100%;
            }
        }

        /* --- Drive UI cleanup --- */
        .drive-grid {
            display: grid;
            grid-template-columns: 1.15fr 0.85fr;
            gap: 16px;
            align-items: start;
        }
        @media (max-width: 980px) {
            .drive-grid { grid-template-columns: 1fr; }
        }
        .drive-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .drive-actions .btn {
            width: 100%;
            justify-content: center;
        }
        .drive-stats {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .drive-stat {
            font-size: 12px;
            color: var(--text);
            border: 1px solid var(--border);
            background: var(--bg);
            padding: 6px 10px;
            border-radius: 999px;
        }
        .drive-stat.muted {
            color: var(--text-light);
        }
        .drive-logs summary {
            cursor: pointer;
            color: var(--text-light);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/" class="back-link">‚Üê Back to Study Guide</a>
        
        <div class="header">
            <div style="display: flex; align-items: center; gap: 24px;">
                <div>
                    <h1>Topics Admin</h1>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 24px;">
                <button class="btn btn-primary" onclick="saveAll()">üíæ Save All Changes</button>
                <div class="user-info">
                    <div class="user-name">
                        {% if session and session.get('user_name') %}
                            {{ session.user_name }}
                        {% elif session and session.get('user_email') %}
                            {{ session.user_email }}
                        {% else %}
                            Local Development
                        {% endif %}
                    </div>
                    {% if request.host.startswith('localhost') or request.host.startswith('127.0.0.1') or request.host.startswith('10.') %}
                    <div class="auth-status local">Local Development</div>
                    {% elif session and session.get('user_email') %}
                    <div class="auth-status authenticated">Authenticated</div>
                    {% else %}
                    <div class="auth-status required">Authentication Required</div>
                    {% endif %}
                    {% if session and session.get('user_email') %}
                    <a href="/auth/logout" class="logout-link">Logout</a>
                    {% endif %}
                </div>
            </div>
        </div>

        <div id="message"></div>

        <div class="card" style="margin-bottom: 24px;">
            <h2 style="margin-top: 0; margin-bottom: 16px;">AI Settings</h2>
            <div class="form-row">
                <div class="input-group">
                    <label for="flashcards-count">Flashcards per topic</label>
                    <input type="number" id="flashcards-count" min="5" max="40" step="1" placeholder="15">
                    <div style="font-size: 0.8rem; color: var(--text-light); margin-top: 6px;">
                        Used when generating üìù Study Notes (Cards are derived from these).
                    </div>
                </div>
                <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>

        {% if drive_enabled %}
        <div class="card" style="margin-bottom: 24px;">
            <h2 style="margin-top: 0; margin-bottom: 8px;">Google Drive (PDF + .ipynb)</h2>
            <div style="margin-bottom: 14px;"></div>

            <div class="drive-grid">
                <div>
                    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom: 10px;">
                        <button class="btn btn-secondary" type="button" onclick="connectDrive()">üîê Connect Drive</button>
                        <div id="drive-status" style="font-size: 0.85rem; color: var(--text-light);">Checking Drive status‚Ä¶</div>
                    </div>

                    <div class="input-group" style="margin: 0;">
                        <label for="drive-folder-id">Drive ID</label>
                        <input type="text" id="drive-folder-id">
                        <div id="drive-folder-stats" class="drive-stats"></div>
                    </div>

                    <div style="display:flex; align-items:center; gap:10px; margin-top: 10px; flex-wrap:wrap;">
                        <label style="display:flex; align-items:center; gap:8px; font-size: 0.85rem; color: var(--text-light); user-select:none;">
                            <input type="checkbox" id="drive-full-run" style="transform: translateY(1px);">
                            Full run (process whole folder ‚Äî can take a long time)
                        </label>
                    </div>

                    <div id="drive-file-detail-row" style="display:none; margin-top: 6px;">
                        <div style="font-size: 0.85rem; color: var(--text-light);">
                            Notes mode: <strong>Deep dive</strong> (single version)
                        </div>
                    </div>

                    <div id="drive-progress" style="display:none; margin-top: 12px;">
                        <div style="display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:6px;">
                            <div id="drive-progress-label" style="font-size: 0.85rem; color: var(--text-light);">Working‚Ä¶</div>
                            <div id="drive-progress-eta" style="font-size: 0.8rem; color: var(--text-light);">Estimating‚Ä¶</div>
                        </div>
                        <div style="height: 10px; width: 100%; background: rgba(0,0,0,0.08); border: 1px solid var(--border); border-radius: 999px; overflow:hidden;">
                            <div id="drive-progress-bar" style="height: 100%; width: 0%; background: linear-gradient(90deg, rgba(59,130,246,0.85), rgba(124,58,237,0.85)); transition: width 120ms linear;"></div>
                        </div>
                    </div>
                </div>

                <div class="drive-actions">
                    <button class="btn btn-primary" type="button" onclick="driveRunAllDSMid()" id="drive-run-all-btn">Build DS Guide</button>
                    <button class="btn btn-secondary" type="button" onclick="driveOpenDSMidGuide()" id="drive-open-ds-btn">Open DS Guide</button>
                    <button class="btn btn-secondary" type="button" onclick="driveOpenFlashcards()" id="drive-folder-fc-btn">Study Flashcards</button>

                    <div style="height: 1px; background: var(--border); margin: 6px 0;"></div>
                    <button class="btn btn-primary" type="button" onclick="driveGenerateFileNotes()" id="drive-file-notes-btn" style="display:none;">Generate Notes</button>
                    <button class="btn btn-secondary" type="button" onclick="driveOpenFileNotes()" id="drive-open-file-notes-btn" style="display:none;">Open Notes</button>
                    <button class="btn btn-secondary" type="button" onclick="driveOpenFileFlashcards()" id="drive-open-file-fc-btn" style="display:none;">Study Flashcards</button>
                </div>
            </div>

            <details style="margin-top: 12px;">
                <summary style="cursor:pointer; color: var(--text-light); font-size: 0.9rem;">Advanced (optional)</summary>
                <div style="margin-top: 10px; color: var(--text-light); font-size: 0.85rem;">
                    Tools for folder mode:
                </div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top: 8px;">
                    <button class="btn btn-secondary" type="button" onclick="driveIndex()">Index (scan items)</button>
                    <button class="btn btn-secondary" type="button" onclick="driveExtractTopics()">Extract (batch 10)</button>
                    <button class="btn btn-secondary" type="button" onclick="driveGenerateGuide()">Generate concise guide</button>
                    <button class="btn btn-secondary" type="button" onclick="driveOpenGuide()">Open concise guide</button>
                    <button class="btn btn-secondary" type="button" onclick="driveGenerateDSMidGuide()">Generate DS guide</button>
                    <button class="btn btn-secondary" type="button" onclick="driveGenerateFlashcards()">Regenerate flashcards</button>
                </div>
            </details>

            <details class="drive-logs" style="margin-top: 12px;">
                <summary>Show run details (JSON)</summary>
                <div id="drive-output" style="margin-top: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 12px; white-space: pre-wrap; background: var(--bg); border: 1px solid var(--border); padding: 12px; border-radius: 10px; color: #111;"></div>
            </details>
        </div>
        {% endif %}

        <div id="categories-container"></div>

        <div class="card">
            <h2 style="margin-top: 0; margin-bottom: 16px;">Add New Category</h2>
            <div class="add-category-form">
                <div class="form-row">
                    <div class="input-group">
                        <label for="new-category-name">Category Name</label>
                        <input type="text" id="new-category-name" placeholder="e.g., Data Structures">
                    </div>
                    <button class="btn btn-primary" onclick="addCategory()">Add Category</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let topicsData = { categories: [], uncategorized_topics: [] };
        let adminSettings = { flashcards_count: 15 };

        async function loadSettings() {
            try {
                const response = await fetch('/api/admin/settings');
                adminSettings = await response.json();
                const el = document.getElementById('flashcards-count');
                if (el && adminSettings && typeof adminSettings.flashcards_count !== 'undefined') {
                    el.value = adminSettings.flashcards_count;
                }
            } catch (error) {
                // Non-fatal
                console.warn('Error loading settings:', error);
            }
        }

        async function saveSettings() {
            try {
                const el = document.getElementById('flashcards-count');
                const flashcards_count = el ? parseInt(el.value || '15', 10) : 15;
                const response = await fetch('/api/admin/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ flashcards_count })
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Failed to save settings');
                showMessage('‚úÖ Settings saved!', 'success');
            } catch (error) {
                showMessage('Error saving settings: ' + error.message, 'error');
            }
        }

        async function loadTopics() {
            try {
                const response = await fetch('/api/topics');
                topicsData = await response.json();
                renderCategories();
            } catch (error) {
                showMessage('Error loading topics: ' + error.message, 'error');
            }
        }

        // Drive helpers (safe even if Drive UI is hidden)
        function setDriveOutput(obj) {
            const el = document.getElementById('drive-output');
            if (!el) return;
            try {
                el.textContent = typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2);
            } catch (e) {
                el.textContent = String(obj);
            }
        }

        async function refreshDriveStatus() {
            const el = document.getElementById('drive-status');
            if (!el) return;
            try {
                const res = await fetch('/api/drive/status');
                if (res.ok) {
                    const data = await res.json();
                    el.textContent = `Connected as ${data.email || 'unknown'}`;
                    el.style.color = 'var(--success)';
                } else {
                    const data = await res.json().catch(() => ({}));
                    el.textContent = 'Not connected';
                    el.style.color = 'var(--text-light)';
                    if (data && data.auth_url) {
                        // keep auth_url available via output
                        setDriveOutput({ hint: 'Click ‚ÄúConnect Drive‚Äù to authorize.', auth_url: data.auth_url });
                    }
                }
            } catch (e) {
                el.textContent = 'Drive status unavailable';
                el.style.color = 'var(--danger)';
            }
            // Best-effort stats refresh (no-op if folder id empty)
            refreshDriveFolderStats();
        }

        function connectDrive() {
            // This will request drive.readonly scope (works even on localhost now).
            window.location.href = '/auth/login?drive=1';
        }

        function _msToEta(ms) {
            if (!ms || ms < 0) return '‚Äî';
            const s = Math.max(0, Math.round(ms / 1000));
            if (s < 60) return `${s}s`;
            const m = Math.floor(s / 60);
            const r = s % 60;
            return `${m}m ${r}s`;
        }

        let _driveProgressTimer = null;
        function startDriveProgress(label, estimatedMs, basePct = 0, spanPct = 100) {
            const wrap = document.getElementById('drive-progress');
            const bar = document.getElementById('drive-progress-bar');
            const lab = document.getElementById('drive-progress-label');
            const eta = document.getElementById('drive-progress-eta');
            if (!wrap || !bar || !lab || !eta) return;
            wrap.style.display = 'block';
            lab.textContent = label || 'Working‚Ä¶';
            const start = Date.now();
            const dur = Math.max(1200, Number(estimatedMs) || 20000);
            const tick = () => {
                const t = Date.now() - start;
                const p = Math.min(0.985, t / dur); // don't hit 100% until request finishes
                const pct = Math.max(0, Math.min(100, basePct + p * spanPct));
                bar.style.width = `${pct}%`;
                const remaining = Math.max(0, dur - t);
                eta.textContent = `ETA: ${_msToEta(remaining)} (estimated)`;
            };
            if (_driveProgressTimer) clearInterval(_driveProgressTimer);
            tick();
            _driveProgressTimer = setInterval(tick, 150);
        }

        function finishDriveProgress(ok, label) {
            const wrap = document.getElementById('drive-progress');
            const bar = document.getElementById('drive-progress-bar');
            const lab = document.getElementById('drive-progress-label');
            const eta = document.getElementById('drive-progress-eta');
            if (_driveProgressTimer) clearInterval(_driveProgressTimer);
            _driveProgressTimer = null;
            if (!wrap || !bar || !lab || !eta) return;
            lab.textContent = label || (ok ? 'Done' : 'Failed');
            eta.textContent = ok ? 'Complete' : 'Error';
            bar.style.width = ok ? '100%' : bar.style.width;
            setTimeout(() => {
                // keep visible briefly; then hide
                wrap.style.display = 'none';
                bar.style.width = '0%';
                eta.textContent = 'Estimating‚Ä¶';
            }, ok ? 900 : 2200);
        }

        function parseDriveResource(input) {
            const raw = String(input || '').trim();
            if (!raw) return { type: 'unknown', id: '' };

            // Normalize whitespace/newlines in pasted text
            let s = raw;
            try { s = s.replace(/\s+/g, ' ').trim(); } catch (e) {}

            // Folder links:
            // - https://drive.google.com/drive/folders/<FOLDER_ID>?...
            // - https://drive.google.com/drive/u/0/folders/<FOLDER_ID>
            let m = s.match(/\/folders\/([a-zA-Z0-9_-]+)/);
            if (m && m[1]) return { type: 'folder', id: m[1] };

            // File links:
            // - https://drive.google.com/file/d/<FILE_ID>/view
            // - https://docs.google.com/document/d/<FILE_ID>/edit
            // - https://docs.google.com/spreadsheets/d/<FILE_ID>/edit
            // - https://drive.google.com/uc?id=<FILE_ID>&export=download
            // - https://colab.research.google.com/drive/<FILE_ID>
            m = s.match(/colab\.research\.google\.com\/drive\/([a-zA-Z0-9_-]+)/i);
            if (m && m[1]) return { type: 'file', id: m[1] };
            m = s.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
            if (m && m[1]) return { type: 'file', id: m[1] };
            m = s.match(/docs\.google\.com\/(?:document|spreadsheets|presentation)\/d\/([a-zA-Z0-9_-]+)/);
            if (m && m[1]) return { type: 'file', id: m[1] };
            m = s.match(/\/uc\?[^#]*[?&]id=([a-zA-Z0-9_-]+)/);
            if (m && m[1]) return { type: 'file', id: m[1] };

            // Ambiguous /open?id=<ID> (could be file or folder).
            m = s.match(/[?&]id=([a-zA-Z0-9_-]+)/);
            if (m && m[1]) return { type: 'id', id: m[1] };

            // If it's already a bare id, keep it.
            if (/^[a-zA-Z0-9_-]{10,}$/.test(s)) return { type: 'id', id: s };

            return { type: 'unknown', id: raw };
        }

        function getDriveFolderId() {
            const el = document.getElementById('drive-folder-id');
            if (!el) return '';
            const current = String(el.value || '').trim();
            const parsed = parseDriveResource(current);
            // Normalize ONLY folder links to ids for visibility.
            // Do NOT rewrite file links; otherwise they become ambiguous bare ids and the UI can't tell file vs folder.
            if (parsed && parsed.type === 'folder' && parsed.id && parsed.id !== current) el.value = parsed.id;

            // Only folder ids are accepted for folder-scoped operations.
            if (parsed.type === 'folder') return parsed.id.trim();
            if (parsed.type === 'file') return '';
            // For ambiguous ids, assume folder id (most common for this input), but still allow stats/ops.
            if (parsed.type === 'id') return parsed.id.trim();
            return '';
        }

        function getDriveFileId() {
            const el = document.getElementById('drive-folder-id');
            if (!el) return '';
            const current = String(el.value || '').trim();
            const parsed = parseDriveResource(current);
            // Do not rewrite the input for file links; keep the full link visible.
            if (parsed.type === 'file') return (parsed.id || '').trim();
            return '';
        }

        async function driveGenerateFileNotes() {
            const fileId = getDriveFileId();
            if (!fileId) {
                showMessage('Paste a Drive FILE link first', 'error');
                return null;
            }
            const kind = 'file_notes_deep';
            startDriveProgress('Generating notes for file‚Ä¶', 35000);
            setDriveOutput('Generating file notes‚Ä¶');
            try {
                const res = await fetch('/api/drive/file/guide/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file_id: fileId, kind })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'File notes generation failed');
                setDriveOutput(data);
                showMessage('‚úÖ File notes generated!', 'success');
                finishDriveProgress(true, 'File notes generated');
                return data;
            } catch (e) {
                setDriveOutput({ error: e.message || String(e) });
                showMessage('File notes error: ' + (e.message || e), 'error');
                finishDriveProgress(false, 'File notes failed');
                return null;
            }
        }

        async function driveOpenFileNotes() {
            const fileId = getDriveFileId();
            if (!fileId) {
                showMessage('Paste a Drive FILE link first', 'error');
                return;
            }
            const kind = 'file_notes_deep';
            // Auto-generate if missing
            const qs = new URLSearchParams();
            qs.set('file_id', fileId);
            qs.set('kind', kind);
            const check = await fetch(`/api/drive/guide/latest?${qs.toString()}`);
            if (!check.ok) {
                const generated = await driveGenerateFileNotes();
                if (!generated) return;
            }
            window.open(`/drive/guide/view/latest?${qs.toString()}`, '_blank');
        }

        async function driveOpenFileFlashcards() {
            const fileId = getDriveFileId();
            if (!fileId) {
                showMessage('Paste a Drive FILE link first', 'error');
                return;
            }
            const notes_kind = 'file_notes_deep';
            const qs = new URLSearchParams();
            qs.set('file_id', fileId);
            qs.set('kind', 'file_pdf');
            // Auto-regenerate if missing or low-quality deck
            const check = await fetch(`/api/drive/flashcards/latest?${qs.toString()}`);
            let shouldRegen = !check.ok;
            if (check.ok) {
                const existing = await check.json().catch(() => null);
                const deckJson = existing && existing.deck_json ? String(existing.deck_json) : '';
                if (!deckJson || !deckJson.includes('\"evidence\"')) shouldRegen = true;
            }
            if (shouldRegen) {
                startDriveProgress('Generating flashcards for file‚Ä¶', 45000);
                setDriveOutput('Generating file flashcards‚Ä¶');
                const res = await fetch('/api/drive/file/flashcards/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file_id: fileId, kind: 'file_pdf', cards_count: 18, notes_kind })
                });
                const data = await res.json();
                if (!res.ok) {
                    finishDriveProgress(false, 'File flashcards failed');
                    throw new Error(data.error || 'File flashcards generation failed');
                }
                setDriveOutput(data);
                finishDriveProgress(true, `Generated ${data.card_count} cards`);
            }
            window.open(`/drive/flashcards/view/latest?${qs.toString()}`, '_blank');
        }

        function renderDriveFolderHint() {
            const el = document.getElementById('drive-folder-stats');
            const inputEl = document.getElementById('drive-folder-id');
            if (!el || !inputEl) return;
            const raw = String(inputEl.value || '').trim();
            if (!raw) {
                el.innerHTML = '<span class="drive-stat muted">Paste a Drive folder link/id (folder mode) or a file link (file mode).</span>';
                return;
            }
            const parsed = parseDriveResource(raw);
            const fileNotesBtn = document.getElementById('drive-file-notes-btn');
            const openFileNotesBtn = document.getElementById('drive-open-file-notes-btn');
            const openFileFcBtn = document.getElementById('drive-open-file-fc-btn');
            const detailRow = document.getElementById('drive-file-detail-row');
            const runFolderBtn = document.getElementById('drive-run-all-btn');
            const openFolderGuideBtn = document.getElementById('drive-open-ds-btn');
            const openFolderFcBtn = document.getElementById('drive-folder-fc-btn');
            // Toggle file-mode actions
            const showFile = parsed.type === 'file';
            if (fileNotesBtn) fileNotesBtn.style.display = showFile ? 'inline-flex' : 'none';
            if (openFileNotesBtn) openFileNotesBtn.style.display = showFile ? 'inline-flex' : 'none';
            if (openFileFcBtn) openFileFcBtn.style.display = showFile ? 'inline-flex' : 'none';
            if (detailRow) detailRow.style.display = showFile ? 'block' : 'none';
            // Toggle folder-mode primary actions
            const showFolder = !showFile;
            if (runFolderBtn) runFolderBtn.style.display = showFolder ? 'inline-flex' : 'none';
            if (openFolderGuideBtn) openFolderGuideBtn.style.display = showFolder ? 'inline-flex' : 'none';
            if (openFolderFcBtn) openFolderFcBtn.style.display = showFolder ? 'inline-flex' : 'none';

            if (parsed.type === 'file') {
                el.innerHTML = `<span class="drive-stat" style="border-color: rgba(239,68,68,0.45);">Detected: <strong>File</strong></span>
                                <span class="drive-stat muted">File mode: generate notes / flashcards for this file.</span>`;
                return;
            }
            if (parsed.type === 'folder') {
                el.innerHTML = `<span class="drive-stat">Detected: <strong>Folder</strong></span>
                                <span class="drive-stat muted">Folder mode: build guides / flashcards for the folder.</span>`;
                return;
            }
            if (parsed.type === 'id') {
                el.innerHTML = `<span class="drive-stat">Detected: <strong>ID</strong></span>
                                <span class="drive-stat muted">Assuming folder mode. If you meant a file, paste a full file link.</span>`;
                return;
            }
            el.innerHTML = `<span class="drive-stat muted">Unrecognized link ‚Äî please paste a Drive folder link/id.</span>`;
        }

        async function driveFolderStats() {
            try {
                const folderId = getDriveFolderId();
                if (!folderId) return null;
                const res = await fetch(`/api/drive/folder/stats?folder_id=${encodeURIComponent(folderId)}`);
                if (!res.ok) return null;
                return await res.json();
            } catch (e) {
                return null;
            }
        }

        function renderDriveFolderStats(stats) {
            const el = document.getElementById('drive-folder-stats');
            if (!el) return;
            if (!stats) {
                el.innerHTML = '<span class="drive-stat muted">No folder stats yet ‚Äî click ‚ÄúIndex Folder‚Äù or ‚ÄúRun DS Guide‚Äù.</span>';
                return;
            }
            const total = Number(stats.total || 0);
            const pdf = Number(stats.pdf_total || 0);
            const extracted = Number(stats.extracted_total || 0);
            const excerpts = Number(stats.excerpt_total || 0);
            el.innerHTML = `
                <span class="drive-stat">PDFs: <strong>${pdf}</strong></span>
                <span class="drive-stat">Indexed: <strong>${total}</strong></span>
                <span class="drive-stat">Extracted: <strong>${extracted}</strong></span>
                <span class="drive-stat">Excerpts: <strong>${excerpts}</strong></span>
            `;
        }

        async function refreshDriveFolderStats() {
            renderDriveFolderHint();
            const stats = await driveFolderStats();
            // Only overwrite the hint with stats if we successfully fetched stats (i.e., folder id is usable).
            if (stats) renderDriveFolderStats(stats);
            return stats;
        }

        let _driveFolderInputTimer = null;
        function onDriveFolderInputChanged() {
            if (_driveFolderInputTimer) clearTimeout(_driveFolderInputTimer);
            // If user pasted a URL, normalize it to a folder id immediately.
            try { getDriveFolderId(); } catch (e) {}
            renderDriveFolderHint();
            _driveFolderInputTimer = setTimeout(() => refreshDriveFolderStats(), 450);
        }

        async function driveIndex() {
            const folderId = getDriveFolderId();
            if (!folderId) {
                showMessage('Paste a Drive FOLDER link/id first', 'error');
                return;
            }
            // Estimate: indexing is mostly metadata; usually quick but scales with file count.
            startDriveProgress('Indexing folder‚Ä¶', 2000 + 35 * 1000); // default 37s-ish until we have counts
            setDriveOutput('Indexing‚Ä¶');
            try {
                const res = await fetch('/api/drive/index', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder_id: folderId })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Index failed');
                setDriveOutput(data);
                showMessage(`‚úÖ Indexed ${data.indexed} files`, 'success');
                // Refine estimate display after the fact for future runs (based on total_seen)
                // (No-op here; progress bar completes on response.)
                finishDriveProgress(true, `Indexed ${data.indexed} files`);
                refreshDriveFolderStats();
            } catch (e) {
                setDriveOutput({ error: e.message || String(e) });
                showMessage('Drive index error: ' + (e.message || e), 'error');
                finishDriveProgress(false, 'Index failed');
            }
            refreshDriveStatus();
        }

        async function driveExtractTopics() {
            const stats = await driveFolderStats();
            const approxFiles = stats ? (stats.pdf_total || stats.total || 10) : 10;
            // Estimate: extraction downloads+parses+AI; scales roughly with files processed.
            // This button processes one batch (limit=10).
            const batch = 10;
            const estMs = 6000 * Math.min(batch, approxFiles) + 4000;
            startDriveProgress(`Extracting (batch of ${batch})‚Ä¶`, estMs);
            setDriveOutput('Extracting topics‚Ä¶');
            try {
                const folderId = getDriveFolderId();
                const res = await fetch('/api/drive/extract-topics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ limit: 10, force: false, folder_id: folderId })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Extract failed');
                setDriveOutput(data);
                showMessage(`‚úÖ Extracted topics from ${data.count} files`, 'success');
                finishDriveProgress(true, `Extracted ${data.count} files`);
                refreshDriveFolderStats();
            } catch (e) {
                setDriveOutput({ error: e.message || String(e) });
                showMessage('Drive extract error: ' + (e.message || e), 'error');
                finishDriveProgress(false, 'Extract failed');
            }
            refreshDriveStatus();
        }

        async function driveGenerateGuide() {
            const stats = await driveFolderStats();
            const approx = stats ? (stats.pdf_total || stats.extracted_total || 20) : 20;
            // Estimate: one LLM call; still correlates with size of topic inventory. Heuristic.
            const estMs = 30000 + Math.min(90000, approx * 1800);
            startDriveProgress(`Generating concise guide‚Ä¶ (${approx} files indexed)`, estMs);
            setDriveOutput('Generating concise guide‚Ä¶ (this can take 30‚Äì90s)');
            try {
                const folderId = getDriveFolderId();
                const res = await fetch('/api/drive/guide/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ kind: 'concise', max_topics: 160, folder_id: folderId })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Guide generation failed');
                setDriveOutput(data);
                showMessage('‚úÖ Guide generated!', 'success');
                finishDriveProgress(true, 'Guide generated');
            } catch (e) {
                setDriveOutput({ error: e.message || String(e) });
                showMessage('Guide generation error: ' + (e.message || e), 'error');
                finishDriveProgress(false, 'Guide generation failed');
            }
        }

        async function driveOpenGuide() {
            try {
                const folderId = getDriveFolderId();
                if (!folderId) {
                    showMessage('Paste a Drive FOLDER link/id to open the folder guide', 'error');
                    return;
                }
                const qs = folderId ? `?folder_id=${encodeURIComponent(folderId)}` : '';
                window.open(`/drive/guide/view/latest${qs}`, '_blank');
            } catch (e) {
                showMessage('Open guide error: ' + (e.message || e), 'error');
            }
        }

        async function driveGenerateDSMidGuide() {
            const stats = await driveFolderStats();
            const approx = stats ? (stats.pdf_total || stats.extracted_total || 20) : 20;
            const estMs = 45000 + Math.min(120000, approx * 2200);
            startDriveProgress(`Generating DS (mid) guide‚Ä¶ (${approx} files indexed)`, estMs);
            setDriveOutput('Generating DS (mid) interview guide‚Ä¶ (this can take 45‚Äì120s)');
            try {
                const folderId = getDriveFolderId();
                const res = await fetch('/api/drive/guide/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ kind: 'ds_mid', max_topics: 200, folder_id: folderId })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Guide generation failed');
                setDriveOutput(data);
                showMessage('‚úÖ DS guide generated!', 'success');
                finishDriveProgress(true, 'DS guide generated');
            } catch (e) {
                setDriveOutput({ error: e.message || String(e) });
                showMessage('DS guide generation error: ' + (e.message || e), 'error');
                finishDriveProgress(false, 'DS guide generation failed');
            }
        }

        function driveOpenDSMidGuide() {
            try {
                const folderId = getDriveFolderId();
                if (!folderId) {
                    // If user pasted a file link, they should use file-mode notes instead.
                    const fileId = getDriveFileId();
                    if (fileId) {
                        showMessage('That looks like a FILE link. Use ‚ÄúOpen Notes (File)‚Äù instead.', 'error');
                        return;
                    }
                    showMessage('Paste a Drive FOLDER link/id to open the folder DS guide', 'error');
                    return;
                }
                const qs = new URLSearchParams();
                qs.set('kind', 'ds_mid');
                if (folderId) qs.set('folder_id', folderId);
                window.open(`/drive/guide/view/latest?${qs.toString()}`, '_blank');
            } catch (e) {
                showMessage('Open DS guide error: ' + (e.message || e), 'error');
            }
        }

        async function driveGenerateFlashcards() {
            const stats = await driveFolderStats();
            const approx = stats ? (stats.pdf_total || 10) : 10;
            const limitFiles = 6;
            const estMs = 15000 + Math.min(120000, Math.min(limitFiles, approx) * 12000);
            startDriveProgress(`Generating flashcards‚Ä¶ (${Math.min(limitFiles, approx)} PDFs)`, estMs);
            setDriveOutput('Generating flashcards‚Ä¶ (this can take 30‚Äì120s depending on files)');
            try {
                const folderId = getDriveFolderId();
                const res = await fetch('/api/drive/flashcards/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ kind: 'ds_mid', folder_id: folderId, limit_files: 6, cards_per_file: 8, max_total: 120 })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Flashcard generation failed');
                setDriveOutput(data);
                showMessage(`‚úÖ Generated ${data.card_count} flashcards`, 'success');
                finishDriveProgress(true, `Generated ${data.card_count} cards`);
                return data;
            } catch (e) {
                setDriveOutput({ error: e.message || String(e) });
                showMessage('Flashcard generation error: ' + (e.message || e), 'error');
                finishDriveProgress(false, 'Flashcard generation failed');
                return null;
            }
        }

        async function driveOpenFlashcards() {
            try {
                const folderId = getDriveFolderId();
                if (!folderId) {
                    const fileId = getDriveFileId();
                    if (fileId) {
                        showMessage('That looks like a FILE link. Use ‚ÄúStudy Flashcards (File PDF)‚Äù instead.', 'error');
                        return;
                    }
                    showMessage('Paste a Drive FOLDER link/id to study folder flashcards', 'error');
                    return;
                }
                const qs = new URLSearchParams();
                qs.set('kind', 'ds_mid');
                if (folderId) qs.set('folder_id', folderId);
                // If there's no deck yet, auto-generate then open (smoother flow).
                const check = await fetch(`/api/drive/flashcards/latest?${qs.toString()}`);
                let shouldRegen = false;
                if (check.ok) {
                    // If this is an older deck (before evidence gating) or contains low-quality "not answered" cards,
                    // regenerate automatically so the user always sees the improved deck.
                    const existing = await check.json().catch(() => null);
                    const deckJson = existing && existing.deck_json ? String(existing.deck_json) : '';
                    if (!deckJson) shouldRegen = true;
                    if (deckJson && (deckJson.includes('not answered in the excerpt') || deckJson.includes('cannot be determined'))) {
                        shouldRegen = true;
                    }
                    if (deckJson && !deckJson.includes('"evidence"')) {
                        shouldRegen = true;
                    }
                } else {
                    shouldRegen = true;
                }
                if (shouldRegen) {
                    const generated = await driveGenerateFlashcards();
                    if (!generated) return;
                }
                window.open(`/drive/flashcards/view/latest?${qs.toString()}`, '_blank');
            } catch (e) {
                showMessage('Open flashcards error: ' + (e.message || e), 'error');
            }
        }

        function setDriveBusy(isBusy, label) {
            const runBtn = document.getElementById('drive-run-all-btn');
            const openBtn = document.getElementById('drive-open-ds-btn');
            if (runBtn) {
                runBtn.disabled = !!isBusy;
                runBtn.textContent = isBusy ? (label || 'Working‚Ä¶') : 'Build DS Guide';
            }
            if (openBtn) openBtn.disabled = !!isBusy;
        }

        async function driveRunAllDSMid() {
            const folderId = getDriveFolderId();
            if (!folderId) {
                showMessage('Paste a Drive FOLDER link/id first', 'error');
                return;
            }

            setDriveBusy(true, 'Checking auth‚Ä¶');
            try {
                // Ensure Drive is connected; if not, redirect to auth.
                const st = await fetch('/api/drive/status');
                if (!st.ok) {
                    const data = await st.json().catch(() => ({}));
                    if (data && data.auth_url) {
                        setDriveBusy(false);
                        window.location.href = data.auth_url;
                        return;
                    }
                    throw new Error(data.error || 'Drive not connected');
                }

                // 1) Index
                startDriveProgress('Indexing folder‚Ä¶', 25000, 0, 20);
                setDriveBusy(true, 'Indexing‚Ä¶');
                setDriveOutput('Indexing folder‚Ä¶');
                let res = await fetch('/api/drive/index', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder_id: folderId })
                });
                let data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Index failed');
                setDriveOutput(data);
                await refreshDriveFolderStats();

                // 2) Extract in batches
                // IMPORTANT: the guide only includes what we've extracted. For parent folders with many subfolders,
                // we may need multiple runs. We'll dynamically size batches based on remaining PDFs, with a safety cap.
                const stats = await driveFolderStats();
                const pdfTotal = stats ? Number(stats.pdf_total || 0) : 0;
                const extractedTotal = stats ? Number(stats.extracted_total || 0) : 0;
                const remaining = Math.max(0, pdfTotal - extractedTotal);
                const batchSize = 10;
                const fullRun = !!document.getElementById('drive-full-run')?.checked;
                const safetyCapBatches = fullRun ? 500 : 50; // full run: up to 5000 files; default: 500 files
                const maxBatches = Math.max(1, Math.min(safetyCapBatches, Math.ceil((remaining || (batchSize * 8)) / batchSize)));

                const approxFiles = stats ? (stats.pdf_total || stats.total || 20) : 20;
                startDriveProgress(
                    `Extracting topics‚Ä¶ (${fullRun ? 'full run' : 'standard'} ‚Ä¢ up to ${Math.min(maxBatches * batchSize, remaining || approxFiles)} files)`,
                    10000 + Math.min(fullRun ? 900000 : 220000, Math.min(maxBatches * batchSize, Math.max(remaining || 0, 40)) * 2500),
                    20,
                    60
                );
                for (let i = 0; i < maxBatches; i++) {
                    setDriveBusy(true, `Extracting‚Ä¶ (${i + 1}/${maxBatches})`);
                    res = await fetch('/api/drive/extract-topics', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ limit: 10, force: false, folder_id: folderId })
                    });
                    data = await res.json();
                    if (!res.ok) throw new Error(data.error || 'Extract failed');
                    setDriveOutput(data);
                    // Stop early when nothing left to process.
                    if (!data || !data.count) break;
                    // Small pause so UI updates feel responsive.
                    await new Promise(r => setTimeout(r, 250));
                }
                await refreshDriveFolderStats();

                // 3) Generate DS guide
                startDriveProgress('Generating DS (mid) guide‚Ä¶', 45000 + Math.min(120000, approxFiles * 2200), 80, 20);
                setDriveBusy(true, 'Generating DS guide‚Ä¶');
                setDriveOutput('Generating DS (mid) interview guide‚Ä¶');
                res = await fetch('/api/drive/guide/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ kind: 'ds_mid', max_topics: 220, folder_id: folderId })
                });
                data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Guide generation failed');
                setDriveOutput(data);
                showMessage('‚úÖ DS guide generated!', 'success');
                finishDriveProgress(true, 'DS guide generated');

            } catch (e) {
                setDriveOutput({ error: e.message || String(e) });
                showMessage('Run failed: ' + (e.message || e), 'error');
                finishDriveProgress(false, 'Run failed');
            } finally {
                setDriveBusy(false);
                refreshDriveStatus();
            }
        }
        // end Drive helpers

        // Initialize
        loadSettings();
        loadTopics();
        // Initialize Drive UI only if it's present on the page
        try {
            if (document.getElementById('drive-status')) {
                refreshDriveStatus();
                const f = document.getElementById('drive-folder-id');
                if (f) {
                    f.addEventListener('input', onDriveFolderInputChanged);
                    f.addEventListener('change', () => refreshDriveFolderStats());
                }
            }
        } catch (e) {}

        // Recursive function to render a node (category/subcategory) at any depth
        function renderNode(node, path, depth = 0) {
            const nodeIndex = path[path.length - 1];
            const pathString = path.join('-');
            const hasSubcategories = node.subcategories && node.subcategories.length > 0;
            const hasDirectTopics = node.topics && node.topics.length > 0;
            
            let html = '';
            const indent = depth * 20;
            const fontSize = Math.max(0.875, 1 - (depth * 0.05));
            
            // Render subcategories recursively
            let subcategoriesHtml = '';
            if (hasSubcategories) {
                node.subcategories.forEach((subcat, subcatIndex) => {
                    const newPath = [...path, subcatIndex];
                    subcategoriesHtml += renderNode(subcat, newPath, depth + 1);
                });
            }
            
            // Render direct topics
            let topicsHtml = '';
            if (hasDirectTopics) {
                node.topics.forEach((topic, topicIndex) => {
                    const topicPathString = [...path, 'topic', topicIndex].join('-');
                    topicsHtml += `
                        <li class="topic-item">
                            <input type="text" class="topic-name" value="${topic}" 
                                   onchange="updateTopicByPath([${path.join(',')}], ${topicIndex}, this.value)"
                                   style="border: none; background: transparent; flex: 1; padding: 0;">
                            <div class="topic-actions">
                                <button class="btn btn-danger btn-small" onclick="deleteTopicByPath([${path.join(',')}], ${topicIndex})">√ó</button>
                            </div>
                        </li>
                    `;
                });
            }
            
            // Check if there's any content to toggle
            // Always show toggle button for subcategories, even if empty (so they look consistent)
            const hasContent = hasSubcategories || hasDirectTopics;
            const showToggle = hasContent || depth > 0; // Show toggle for all subcategories (depth > 0) or if they have content
            
            // Build the node HTML
            const sectionId = `section-${pathString}`;
            html += `
                <div class="subcategory-section" style="margin-left: ${indent}px; ${depth > 0 ? 'border-left: 2px solid var(--border); padding-left: 16px;' : ''}">
                    <div class="subcategory-header">
                        <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                            ${showToggle ? `<button class="toggle-btn" onclick="toggleSection('${sectionId}')" title="Toggle section">${hasContent ? '‚ñº' : '‚ñ∂'}</button>` : '<span style="width: 24px;"></span>'}
                            <input type="text" class="subcategory-title" value="${node.name}" 
                                   onchange="updateNodeNameByPath([${path.join(',')}], this.value)"
                                   style="border: none; background: transparent; font-size: ${fontSize}rem; font-weight: 600; padding: 0; width: 100%; max-width: ${600 - depth * 50}px;">
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-secondary btn-small" onclick="addSubcategoryByPath([${path.join(',')}])">+ Add Subcategory</button>
                            <button class="btn btn-secondary btn-small" onclick="addTopicByPath([${path.join(',')}])">+ Add Topic</button>
                            ${depth > 0 ? `<button class="btn btn-danger btn-small" onclick="deleteNodeByPath([${path.join(',')}])">Delete</button>` : ''}
                        </div>
                    </div>
                    <div class="subcategory-content ${hasContent ? '' : 'hidden'}" id="${sectionId}">
                        ${subcategoriesHtml}
                        ${hasDirectTopics ? `<ul class="topics-list">${topicsHtml}</ul>` : ''}
                        <div class="add-topic-form">
                            <div class="form-row">
                                <div class="input-group">
                                    <input type="text" id="new-topic-${pathString}" placeholder="Add new topic..." 
                                           onkeypress="if(event.key==='Enter') addTopicByPath([${path.join(',')}])">
                                </div>
                                <button class="btn btn-secondary btn-small" onclick="addTopicByPath([${path.join(',')}])">Add Topic</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            return html;
        }

        function renderCategories() {
            const container = document.getElementById('categories-container');
            container.innerHTML = '';

            topicsData.categories.forEach((category, catIndex) => {
                const card = document.createElement('div');
                card.className = 'card';
                
                const hasSubcategories = category.subcategories && category.subcategories.length > 0;
                const hasDirectTopics = category.topics && category.topics.length > 0;
                
                let subcategoriesContainer = '';
                if (hasSubcategories) {
                    category.subcategories.forEach((subcat, subcatIndex) => {
                        subcategoriesContainer += renderNode(subcat, [catIndex, subcatIndex], 0);
                    });
                }
                
                // Render direct topics if they exist
                let directTopicsHtml = '';
                if (hasDirectTopics) {
                    category.topics.forEach((topic, topicIndex) => {
                        directTopicsHtml += `
                            <li class="topic-item">
                                <input type="text" class="topic-name" value="${topic}" 
                                       onchange="updateTopicByPath([${catIndex}], ${topicIndex}, this.value)"
                                       style="border: none; background: transparent; flex: 1; padding: 0;">
                                <div class="topic-actions">
                                    <button class="btn btn-danger btn-small" onclick="deleteTopicByPath([${catIndex}], ${topicIndex})">√ó</button>
                                </div>
                            </li>
                        `;
                    });
                }
                
                const categorySectionId = `category-section-${catIndex}`;
                const categoryHasContent = hasSubcategories || hasDirectTopics;
                
                card.innerHTML = `
                    <div class="category-header">
                        <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                            ${categoryHasContent ? `<button class="toggle-btn" onclick="toggleSection('${categorySectionId}')" title="Toggle category">‚ñº</button>` : '<span style="width: 24px;"></span>'}
                            <input type="text" class="category-title" value="${category.name}" 
                                   onchange="updateCategoryName(${catIndex}, this.value)"
                                   style="border: none; background: transparent; font-size: 1.25rem; font-weight: 600; padding: 0; width: 100%; max-width: 800px;">
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-secondary btn-small" onclick="addSubcategory(${catIndex})">+ Add Subcategory</button>
                            <button class="btn btn-secondary btn-small" onclick="addTopicByPath([${catIndex}])">+ Add Topic</button>
                            <button class="btn btn-danger btn-small" onclick="deleteCategory(${catIndex})">Delete Category</button>
                        </div>
                    </div>
                    <div class="subcategory-content ${categoryHasContent ? '' : 'hidden'}" id="${categorySectionId}">
                        ${subcategoriesContainer}
                        ${hasDirectTopics ? `
                            <div class="subcategory-section" style="margin-top: ${hasSubcategories ? '20' : '0'}px;">
                                <div class="subcategory-header" style="margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border);">
                                    <div style="font-size: 0.9375rem; font-weight: 600; color: var(--text);">Topics</div>
                                </div>
                                <ul class="topics-list">${directTopicsHtml}</ul>
                                <div class="add-topic-form">
                                    <div class="form-row">
                                        <div class="input-group">
                                            <input type="text" id="new-topic-${catIndex}" placeholder="Add new topic..." 
                                                   onkeypress="if(event.key==='Enter') addTopicByPath([${catIndex}])">
                                        </div>
                                        <button class="btn btn-secondary btn-small" onclick="addTopicByPath([${catIndex}])">Add Topic</button>
                                    </div>
                                </div>
                            </div>
                        ` : ''}
                        ${!hasDirectTopics ? `
                            <div class="add-topic-form">
                                <div class="form-row">
                                    <div class="input-group">
                                        <input type="text" id="new-topic-${catIndex}" placeholder="Add new topic..." 
                                               onkeypress="if(event.key==='Enter') addTopicByPath([${catIndex}])">
                                    </div>
                                    <button class="btn btn-secondary btn-small" onclick="addTopicByPath([${catIndex}])">Add Topic</button>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function addCategory() {
            const nameInput = document.getElementById('new-category-name');
            const name = nameInput.value.trim();
            if (!name) {
                showMessage('Please enter a category name', 'error');
                return;
            }
            topicsData.categories.push({ name, subcategories: [] });
            nameInput.value = '';
            renderCategories();
            showMessage('Category added. Don\'t forget to save!', 'success');
        }

        function updateCategoryName(catIndex, newName) {
            topicsData.categories[catIndex].name = newName.trim();
        }

        function deleteCategory(catIndex) {
            if (confirm(`Delete category "${topicsData.categories[catIndex].name}" and all its subcategories and topics?`)) {
                topicsData.categories.splice(catIndex, 1);
                renderCategories();
                showMessage('Category deleted. Don\'t forget to save!', 'success');
            }
        }

        function addSubcategory(catIndex) {
            const name = prompt('Enter subcategory name:');
            if (!name || !name.trim()) {
                return;
            }
            if (!topicsData.categories[catIndex].subcategories) {
                topicsData.categories[catIndex].subcategories = [];
            }
            topicsData.categories[catIndex].subcategories.push({ name: name.trim(), topics: [] });
            renderCategories();
            // Show the category content section if it was hidden
            const categorySectionId = `category-section-${catIndex}`;
            const categoryContentSection = document.getElementById(categorySectionId);
            if (categoryContentSection) {
                categoryContentSection.classList.remove('hidden');
            }
            showMessage('Subcategory added. Don\'t forget to save!', 'success');
        }

        // Helper function to get node by path
        function getNodeByPath(path) {
            let node = topicsData.categories[path[0]];
            for (let i = 1; i < path.length; i++) {
                if (!node.subcategories) node.subcategories = [];
                node = node.subcategories[path[i]];
            }
            return node;
        }

        // Helper function to get parent node by path
        function getParentNodeByPath(path) {
            if (path.length <= 1) return topicsData.categories;
            let node = topicsData.categories[path[0]];
            for (let i = 1; i < path.length - 1; i++) {
                if (!node.subcategories) node.subcategories = [];
                node = node.subcategories[path[i]];
            }
            return node.subcategories;
        }

        function addSubcategoryByPath(path) {
            const name = prompt('Enter subcategory name:');
            if (!name || !name.trim()) {
                return;
            }
            const node = getNodeByPath(path);
            if (!node.subcategories) node.subcategories = [];
            node.subcategories.push({ name: name.trim(), topics: [] });
            renderCategories();
            // Show the content section if it was hidden
            const pathString = path.join('-');
            const sectionId = `section-${pathString}`;
            const contentSection = document.getElementById(sectionId);
            if (contentSection) {
                contentSection.classList.remove('hidden');
            }
            showMessage('Subcategory added. Don\'t forget to save!', 'success');
        }

        function addTopicByPath(path) {
            const pathString = path.join('-');
            const input = document.getElementById(`new-topic-${pathString}`);
            const topic = input ? input.value.trim() : '';
            if (!topic) {
                showMessage('Please enter a topic name', 'error');
                return;
            }
            const node = getNodeByPath(path);
            if (!node.topics) node.topics = [];
            node.topics.push(topic);
            if (input) input.value = '';
            renderCategories();
            // Show the content section if it was hidden
            const sectionId = `section-${pathString}`;
            const contentSection = document.getElementById(sectionId);
            if (contentSection) {
                contentSection.classList.remove('hidden');
            }
            // Also show parent category content if adding to a category
            if (path.length === 1) {
                const categorySectionId = `category-section-${path[0]}`;
                const categoryContentSection = document.getElementById(categorySectionId);
                if (categoryContentSection) {
                    categoryContentSection.classList.remove('hidden');
                }
            }
            showMessage('Topic added. Don\'t forget to save!', 'success');
        }

        function updateNodeNameByPath(path, newName) {
            const node = getNodeByPath(path);
            node.name = newName.trim();
        }

        function updateTopicByPath(path, topicIndex, newValue) {
            const node = getNodeByPath(path);
            if (!node.topics) node.topics = [];
            node.topics[topicIndex] = newValue.trim();
        }

        function deleteNodeByPath(path) {
            const node = getNodeByPath(path);
            if (confirm(`Delete "${node.name}" and all its subcategories and topics?`)) {
                const parent = getParentNodeByPath(path);
                parent.splice(path[path.length - 1], 1);
                renderCategories();
                showMessage('Deleted. Don\'t forget to save!', 'success');
            }
        }

        function deleteTopicByPath(path, topicIndex) {
            const node = getNodeByPath(path);
            const topic = node.topics[topicIndex];
            if (confirm(`Delete topic "${topic}"?`)) {
                node.topics.splice(topicIndex, 1);
                renderCategories();
                showMessage('Topic deleted. Don\'t forget to save!', 'success');
            }
        }

        function toggleSection(sectionId) {
            const contentSection = document.getElementById(sectionId);
            if (!contentSection) return;
            
            // Find the toggle button - it could be in a category-header or subcategory-header
            const card = contentSection.closest('.card, .subcategory-section');
            if (!card) return;
            
            // Toggle the collapsed class on the content section
            contentSection.classList.toggle('hidden');
            
            // Find and update the toggle button
            const toggleBtn = card.querySelector('.toggle-btn');
            if (toggleBtn) {
                toggleBtn.textContent = contentSection.classList.contains('hidden') ? '‚ñ∂' : '‚ñº';
            }
        }

        function updateSubcategoryName(catIndex, subcatIndex, newName) {
            topicsData.categories[catIndex].subcategories[subcatIndex].name = newName.trim();
        }

        function deleteSubcategory(catIndex, subcatIndex) {
            const subcat = topicsData.categories[catIndex].subcategories[subcatIndex];
            if (confirm(`Delete subcategory "${subcat.name}" and all its topics?`)) {
                topicsData.categories[catIndex].subcategories.splice(subcatIndex, 1);
                renderCategories();
                showMessage('Subcategory deleted. Don\'t forget to save!', 'success');
            }
        }

        function addTopic(catIndex, subcatIndex) {
            const input = document.getElementById(`new-topic-${catIndex}-${subcatIndex}`);
            const topic = input.value.trim();
            if (!topic) {
                showMessage('Please enter a topic name', 'error');
                return;
            }
            topicsData.categories[catIndex].subcategories[subcatIndex].topics.push(topic);
            input.value = '';
            renderCategories();
            showMessage('Topic added. Don\'t forget to save!', 'success');
        }

        function updateTopic(catIndex, subcatIndex, topicIndex, newValue) {
            topicsData.categories[catIndex].subcategories[subcatIndex].topics[topicIndex] = newValue.trim();
        }

        function deleteTopic(catIndex, subcatIndex, topicIndex) {
            const topic = topicsData.categories[catIndex].subcategories[subcatIndex].topics[topicIndex];
            if (confirm(`Delete topic "${topic}"?`)) {
                topicsData.categories[catIndex].subcategories[subcatIndex].topics.splice(topicIndex, 1);
                renderCategories();
                showMessage('Topic deleted. Don\'t forget to save!', 'success');
            }
        }

        // Legacy topic functions (for categories with direct topics)
        function updateLegacyTopic(catIndex, topicIndex, newValue) {
            if (!topicsData.categories[catIndex].topics) {
                topicsData.categories[catIndex].topics = [];
            }
            topicsData.categories[catIndex].topics[topicIndex] = newValue.trim();
        }

        function deleteLegacyTopic(catIndex, topicIndex) {
            const topic = topicsData.categories[catIndex].topics[topicIndex];
            if (confirm(`Delete topic "${topic}"?`)) {
                topicsData.categories[catIndex].topics.splice(topicIndex, 1);
                renderCategories();
                showMessage('Topic deleted. Don\'t forget to save!', 'success');
            }
        }

        async function saveAll() {
            try {
                const response = await fetch('/api/topics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(topicsData)
                });

                const data = await response.json();
                if (response.ok) {
                    showMessage('‚úÖ Topics saved successfully!', 'success');
                } else {
                    showMessage('Error: ' + (data.error || 'Failed to save'), 'error');
                }
            } catch (error) {
                showMessage('Error saving topics: ' + error.message, 'error');
            }
        }

        function showMessage(text, type) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.className = `message message-${type}`;
            messageEl.style.display = 'block';
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 5000);
        }

        // Load topics on page load (handled above with settings init)
    </script>
</body>
</html>

